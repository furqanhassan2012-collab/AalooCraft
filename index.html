<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Potatocraft â€” Starter Demo</title>
  <style>
    :root{--ui-bg:#111;--panel-bg:#0f1720;--text:#e6eef8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#9ad98b 0%, #7cc66a 100%);}
    .container{display:flex;gap:12px;padding:12px}
    canvas{background:transparent;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.25)}
    .panel{width:340px;background:var(--panel-bg);color:var(--text);padding:12px;border-radius:8px;font-size:14px}
    h1{margin:0 0 8px 0;font-size:18px}
    .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    button{background:#2b3944;color:var(--text);border:0;padding:8px;border-radius:6px;cursor:pointer}
    button:active{transform:translateY(1px)}
    .big{font-weight:700}
    .hearts{display:flex;gap:6px}
    .weapon-list, .armor-list{display:flex;flex-direction:column;gap:6px;margin-bottom:8px}
    .dim-btn{padding:6px 8px;border-radius:6px}
    .footer{font-size:12px;opacity:0.85}
  </style>
</head>
<body>
  <div class="container">
    <canvas id="game" width="900" height="600"></canvas>
    <div class="panel">
      <h1>Potatocraft â€” Starter Demo</h1>
      <div class="row"><div class="big">Dimension:</div>
        <div style="display:flex;gap:6px">
          <button class="dim-btn" id="dim-over">Overworld</button>
          <button class="dim-btn" id="dim-nether">The Fryer</button>
          <button class="dim-btn" id="dim-end">Bag of Chips</button>
        </div>
      </div>

      <div class="row"><div class="big">Health:</div><div class="hearts" id="hearts"></div></div>

      <div class="row"><div class="big">Weapon:</div>
        <div style="flex:1">
          <div class="weapon-list" id="weapons"></div>
        </div>
      </div>

      <div class="row"><div class="big">Armor:</div>
        <div style="flex:1">
          <div class="armor-list" id="armors"></div>
        </div>
      </div>

      <div class="row"><div class="big">Score:</div><div id="score">0</div></div>
      <div class="row"><div class="big">Enemies:</div><div id="enemyCount">0</div></div>

      <div class="row"><button id="spawnWave">Spawn Wave</button><button id="reset">Reset</button></div>

      <div style="margin-top:10px" class="footer">
        Controls: Move with arrow keys / A-D (optional), Space to attack. Choose weapon and armor from the panel. Use dimension buttons to change enemy types & background.
      </div>
    </div>
  </div>

<script>
// Potatocraft â€” single-file starter demo
// Features implemented:
// - Player (person) in center, stationary movement optional
// - Potato-themed enemies spawn from sides and slide toward player
// - Spacebar to attack (melee) with weapon-specific damage/cooldown
// - Weapons: sword, axe, shovel, bow-like (fry launcher simulated)
// - Armor tiers reduce damage
// - Three dimensions (Overworld, The Fryer, Bag of Chips) with different enemy behavior
// - Simple UI for weapon/armor selection, hearts display, score

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Game state
let state = {
  dim: 'overworld',
  score: 0,
  enemies: [],
  lastSpawn: 0,
  spawnInterval: 1500,
  keys: {},
  player: {
    x: W/2, y: H/2+80, w: 36, h: 48,
    maxHp: 3, hp: 3,
    armor: 'potato-peel',
    armorTier: 1,
    facing: 'right'
  },
  weapon: 'potato-stick',
  lastAttack: 0,
  attackCooldown: 400
};

// Weapons metadata
const weapons = {
  'potato-stick': {name:'Potato Stick (Sword)', dmg:1, cd:400, desc:'Fast, low dmg'},
  'fry-cutter': {name:'Fry Cutter (Axe)', dmg:2, cd:700, desc:'High dmg, slow'},
  'potato-masher': {name:'Potato Masher (Pickaxe)', dmg:1.5, cd:600, desc:'Balanced'},
  'spud-digger': {name:'Spud Digger (Shovel)', dmg:1.2, cd:450, desc:'Good at close range'},
  'fry-launcher': {name:'Fry Launcher (Ranged)', dmg:1, cd:600, ranged:true, desc:'Shoots a fry projectile'}
};

// Armor metadata
const armors = {
  'potato-peel': {name:'Potato Peel Armor', tier:1, reduction:0.05},
  'baked-armor': {name:'Baked Armor', tier:2, reduction:0.12},
  'mashed-armor': {name:'Mashed Armor', tier:3, reduction:0.18},
  'golden-potato': {name:'Golden Potato Armor', tier:4, reduction:0.25},
  'crisp-armor': {name:'Crisp Armor', tier:5, reduction:0.35}
};

// Enemy types per dimension
const enemyTypes = {
  overworld: [
    {type:'rotten-potato',hp:1,speed:0.9,score:10,color:'#a87f4e'},
    {type:'potato-pig',hp:1.2,speed:1.0,score:12,color:'#c38f6b'},
    {type:'spud-creeper',hp:1.5,speed:0.7,score:25,color:'#7d8b36',explode:true}
  ],
  fryer: [
    {type:'crisp-lin',hp:1.5,speed:1.1,score:14,color:'#d86f2f'},
    {type:'air-fryer',hp:2.2,speed:0.6,score:30,color:'#4b2f1f',ranged:true},
    {type:'burnt-spud',hp:2,speed:0.8,score:22,color:'#5b3a24'}
  ],
  end: [
    {type:'crisper',hp:2.5,speed:1.0,score:40,color:'#f0d38c',teleport:true},
    {type:'golden-chip',hp:5,speed:0.9,score:200,color:'#ffd54a',boss:true}
  ]
};

// UI wiring
const weaponsDiv = document.getElementById('weapons');
const armorsDiv = document.getElementById('armors');
const heartsDiv = document.getElementById('hearts');
const scoreEl = document.getElementById('score');
const enemyCountEl = document.getElementById('enemyCount');

function setupUI(){
  // weapons
  weaponsDiv.innerHTML='';
  for(const id in weapons){
    const b = document.createElement('button');
    b.textContent = weapons[id].name;
    b.onclick = ()=>{ state.weapon = id; state.attackCooldown = weapons[id].cd; renderUI(); };
    weaponsDiv.appendChild(b);
  }
  // armor
  armorsDiv.innerHTML='';
  for(const id in armors){
    const b = document.createElement('button');
    b.textContent = armors[id].name;
    b.onclick = ()=>{ state.player.armor = id; state.player.armorTier = armors[id].tier; renderUI(); };
    armorsDiv.appendChild(b);
  }
  renderUI();
}

function renderUI(){
  // hearts
  heartsDiv.innerHTML='';
  for(let i=0;i<state.player.maxHp;i++){
    const span = document.createElement('div');
    span.style.width='22px'; span.style.height='22px'; span.style.borderRadius='5px';
    span.style.background = (i < state.player.hp) ? 'url(data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><text x="0" y="18" font-size="18">ðŸ¥”</text></svg>)' : 'rgba(255,255,255,0.08)';
    span.style.backgroundSize='cover';
    heartsDiv.appendChild(span);
  }
  scoreEl.textContent = state.score;
  enemyCountEl.textContent = state.enemies.length;
}

// Spawn enemy function
function spawnEnemy(from){
  const types = enemyTypes[state.dim];
  const template = types[Math.floor(Math.random()*types.length)];
  const side = from || (Math.random()<0.5 ? 'left' : 'right');
  const y = Math.random()*(H-200)+80;
  const x = side==='left' ? -60 : W+60;
  const vx = side==='left' ? template.speed : -template.speed;
  const e = {
    id: Math.random().toString(36).slice(2,9),
    x, y, vx, vy:0, w:44, h:34,
    hp: template.hp, maxHp: template.hp,
    speed: template.speed,
    type: template.type,
    color: template.color,
    score: template.score,
    explode: template.explode||false,
    ranged: template.ranged||false,
    teleport: template.teleport||false,
    boss: template.boss||false
  };
  state.enemies.push(e);
  renderUI();
}

// Basic projectile system for fry-launcher
let projectiles = [];

// Input handling
window.addEventListener('keydown', e=>{ state.keys[e.code]=true; if(e.code==='Space'){ e.preventDefault(); attack(); } });
window.addEventListener('keyup', e=>{ state.keys[e.code]=false; });

function attack(){
  const now = Date.now();
  const w = weapons[state.weapon];
  if(now - state.lastAttack < w.cd) return;
  state.lastAttack = now;
  // ranged
  if(w.ranged){
    // spawn a projectile
    projectiles.push({x: state.player.x, y: state.player.y-20, vx: state.player.facing==='right' ? 6 : -6, dmg: w.dmg, life:120});
    return;
  }
  // melee: check enemies in range
  const range = 70;
  for(let i=state.enemies.length-1;i>=0;i--){
    const en = state.enemies[i];
    const dx = Math.abs(en.x - state.player.x);
    const dy = Math.abs(en.y - state.player.y);
    if(dx < range && dy < 60){
      // hit
      en.hp -= w.dmg;
      if(en.hp <= 0){
        killEnemy(en, i);
      }
    }
  }
}

function killEnemy(en, idx){
  state.score += en.score;
  // small explosion effect for creeper-like
  if(en.explode){ createParticleBurst(en.x,en.y,'#f5d9a6'); }
  state.enemies.splice(idx,1);
  renderUI();
}

// Simple particles
let particles = [];
function createParticleBurst(x,y,color){
  for(let i=0;i<18;i++) particles.push({x,y, vx:(Math.random()-0.5)*4, vy:(Math.random()-0.5)*4, life:30+Math.random()*30, color});
}

// Update loop
function update(dt){
  // spawn logic
  const now = Date.now();
  if(now - state.lastSpawn > state.spawnInterval){
    spawnEnemy();
    state.lastSpawn = now;
  }
  // update enemies
  for(let i=state.enemies.length-1;i>=0;i--){
    const e = state.enemies[i];
    // boss teleport behavior
    if(e.teleport && Math.random() < 0.003){
      e.x = Math.random()*(W-200)+100; e.y = Math.random()*(H-200)+100; createParticleBurst(e.x,e.y,'#fff2b0');
    }
    // move toward player
    const ang = Math.atan2(state.player.y - e.y, state.player.x - e.x);
    e.x += Math.cos(ang)*e.speed;
    e.y += Math.sin(ang)*e.speed*0.6;
    // check collision with player
    if(Math.hypot(e.x - state.player.x, e.y - state.player.y) < 40){
      // damage player
      const rawDmg = 1* (e.boss?2:1);
      const reduction = armors[state.player.armor].reduction || 0;
      const dmg = rawDmg * (1 - reduction);
      // simple hit cooldown per enemy: push back and remove small HP
      if(!e._hitCooldown || now - e._hitCooldown > 800){
        e._hitCooldown = now;
        state.player.hp -= dmg;
        createParticleBurst(state.player.x,state.player.y,'#ff9999');
        if(state.player.hp <= 0){ gameOver(); }
      }
    }
  }
  // update projectiles
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    p.x += p.vx; p.y += p.vy; p.life -= 1;
    // collide with enemy
    for(let j=state.enemies.length-1;j>=0;j--){
      const e = state.enemies[j];
      if(Math.hypot(p.x - e.x, p.y - e.y) < 30){ e.hp -= p.dmg; p.life = 0; if(e.hp<=0) killEnemy(e,j); break; }
    }
    if(p.life<=0) projectiles.splice(i,1);
  }
  // particles
  for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; if(p.life<=0) particles.splice(i,1); }
}

function gameOver(){
  // simple reset with message
  alert('You died! Score: ' + state.score);
  resetGame();
}

function resetGame(){
  state.score = 0; state.enemies = []; projectiles = []; particles = []; state.player.hp = state.player.maxHp; state.lastSpawn = Date.now(); renderUI();
}

// Render functions
function drawPlayer(){
  const p = state.player;
  // body
  ctx.fillStyle = '#e3c9a2'; ctx.fillRect(p.x-12,p.y-30,24,32);
  // head
  ctx.beginPath(); ctx.ellipse(p.x, p.y-44, 14, 16, 0, 0, Math.PI*2); ctx.fill();
  // simple face
  ctx.fillStyle = '#2b2b2b'; ctx.fillRect(p.x-6,p.y-46,3,3); ctx.fillRect(p.x+3,p.y-46,3,3);
}

function drawEnemy(e){
  // potato-shaped oval
  ctx.beginPath(); ctx.ellipse(e.x, e.y, e.w/2, e.h/2, 0, 0, Math.PI*2);
  ctx.fillStyle = e.color; ctx.fill();
  // eyes
  ctx.fillStyle='#2b2b2b'; ctx.fillRect(e.x-6,e.y-6,3,3); ctx.fillRect(e.x+3,e.y-6,3,3);
  // hp bar
  ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(e.x-22,e.y-22,44,6);
  ctx.fillStyle='#66ff66'; ctx.fillRect(e.x-22,e.y-22,44*(e.hp/e.maxHp),6);
}

function drawUIOverlay(){
  // dimension label
  ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(10,10,170,36);
  ctx.fillStyle='#fff'; ctx.font='16px sans-serif'; ctx.fillText('Dimension: ' + state.dim, 18,34);
}

function draw(){
  // background by dimension
  if(state.dim==='overworld'){
    ctx.fillStyle = '#a5e07a'; ctx.fillRect(0,0,W,H);
    // ground
    ctx.fillStyle='#7f7f6a'; ctx.fillRect(0,H-100,W,100);
  } else if(state.dim==='fryer'){
    ctx.fillStyle='#44220f'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#2b1207'; ctx.fillRect(0,H-120,W,120);
  } else if(state.dim==='end'){
    ctx.fillStyle='#1b1b2f'; ctx.fillRect(0,0,W,H);
    // floating platforms
    ctx.fillStyle='#2c2c44'; for(let i=0;i<5;i++) ctx.fillRect(80+i*150, H-170 - (i%2)*30, 120, 18);
  }

  // draw player
  drawPlayer();
  // enemies
  for(const e of state.enemies) drawEnemy(e);
  // projectiles
  ctx.fillStyle='#f2b33b'; for(const p of projectiles) ctx.fillRect(p.x-6,p.y-4,12,6);
  // particles
  for(const p of particles){ ctx.globalAlpha = Math.max(0.05, p.life/60); ctx.fillStyle = p.color; ctx.fillRect(p.x,p.y,4,4); ctx.globalAlpha = 1; }
  drawUIOverlay();
}

// Game loop
let last = Date.now();
function loop(){
  const now = Date.now();
  const dt = now - last; last = now;
  update(dt);
  ctx.clearRect(0,0,W,H);
  draw();
  requestAnimationFrame(loop);
}

// UI buttons
document.getElementById('dim-over').onclick = ()=>{ state.dim='overworld'; state.spawnInterval=1500; resetGame(); };
document.getElementById('dim-nether').onclick = ()=>{ state.dim='fryer'; state.spawnInterval=1200; resetGame(); };
document.getElementById('dim-end').onclick = ()=>{ state.dim='end'; state.spawnInterval=1800; resetGame(); };
document.getElementById('spawnWave').onclick = ()=>{ for(let i=0;i<6;i++) spawnEnemy(i%2? 'left':'right'); };
document.getElementById('reset').onclick = resetGame;

// initial setup
setupUI(); state.lastSpawn = Date.now();
// spawn a few starters
for(let i=0;i<3;i++) spawnEnemy(i%2? 'left':'right');
loop();

</script>
</body>
</html>
